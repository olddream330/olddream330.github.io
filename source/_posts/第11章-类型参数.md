---
title: 第11章 类型参数
date: 2018-08-05 22:02:35
tags: Scala开发快速入门
---

|语法特性|格式|描述|
|:----|:----|:----|
|类型变量界定|<:|is a |
|视图界定|<%|can be seen as |
|上下文界定|T:M|has a |

## 11.1 类与类型

## 11.2 泛型


```scala211
/**
  * Scala泛型：多个参数
  */
object Example11_1 extends App {
    class Person[T](var name: T)
    class Student[T,S](name:T, var age:S) extends Person(name)

    println(new Student[String,Int]("John", 18).name)
}
```


```scala211
/**
  * Scala存在类型
  */
object Example11_2 extends App {
    val arrStr:Array[String]=Array("Hadoop","Hive","Spark")
    val arrInt:Array[Int]=Array(1,2,3)
    printAll(arrStr)
    printAll(arrInt)

    def printAll(x:Array[T] forSome {type T}) = {
        for (i <- x) {
            print(i + " ")
        }
        println()
    }
}
```


```scala211
/**
  * Scala存在类型简化
  * def printAll(x:Array[T] forSome {type T}) 可简化为 def printAll(x:Array[_])
  * _ 类型通配符
  */
object Example11_3 extends App {
    val arrStr:Array[String]=Array("Hadoop","Hive","Spark")
    val arrInt:Array[Int]=Array(1,2,3)
    printAll(arrStr)
    printAll(arrInt)

    def printAll(x:Array[_]) = {
        for (i <- x) {
            print(i + " ")
        }
        println()
    }
}
```

## 11.3 类型变量界定
- 上界 [R <:T]
- 下界 [R >:T]


```scala211
/**
  * 类型变量界定
  */
object Example11_4 extends App {
    case class Person(var name:String,var age:Int) extends Comparable[Person]{
        def compareTo(o:Person):Int={
            if (this.age > o.age) 1
            else if (this.age == o.age) 0
            else -1
        }
    }

    class TypeVariableBound {
        def compare[T <: Comparable[T]](first:T,second:T)={
            if (first.compareTo(second) > 0)
                first
            else
                second
        }
    }

    val tvb = new TypeVariableBound
    println(tvb.compare("A", "B"))
    println(tvb.compare(Person("Stephen",19), Person("Jack",20)))
}
```

## 11.4 视图界定


```scala211
/**
  * 不指定视图界定
  */
object Example11_5 extends App {
    case class Student[T,S <: Comparable[S]](var name:T, var height:S)
    val s = Student("Stephen","168")
}
```


```scala211
/**
  * 指定视图界定
  */
object Example11_6 extends App {
    case class Student[T,S <% Comparable[S]](var name:T, var height:S)
    val s = Student("Stephen",168)
}
```

## 11.5 上下文界定


```scala211
/**
  * 上下文界定
  */
object Example11_7 extends App {
    class PersonOrdering extends Ordering[Person] {
        override def compare(x: Person, y:Person):Int={
            if(x.name > y.name)
                1
            else
                -1
        }
    }

    case class Person(val name:String) {
        println("Constructing " + name)
    }

    class Pair[T:Ordering](val first:T,val second:T) {
        def smaller(implicit ord:Ordering[T])={
            if (ord.compare(first, second) > 0)
                first
            else
                second
        }
    }


    implicit val p1 = new PersonOrdering
    val p = new Pair(Person("123"),Person("456"))
    println(p.smaller)
}
```


```scala211
/**
  * 上下文界定(import Ordered.orderingToOrdered)
  */
object Example11_8 extends App {
    class PersonOrdering extends Ordering[Person] {
        override def compare(x: Person, y:Person):Int={
            if(x.name > y.name)
                1
            else
                -1
        }
    }

    case class Person(val name:String) {
        println("Constructing " + name)
    }

    class Pair[T:Ordering](val first:T,val second:T) {
        import Ordered.orderingToOrdered;
        def smaller(implicit ord:Ordering[T])={
            if (first<second)
                first
            else
                second
        }
    }


    implicit val p1 = new PersonOrdering
    val p = new Pair(Person("123"),Person("456"))
    println(p.smaller)
}

/*
 Note: implicit value p1 is not applicable here because it comes after the application point and it lacks an explicit result type
            if (first<second)
                     ^
one error found
*/
```

## 11.6 多重界定

|多重界定|描述|
|:---|:---------------|
|T:M:K|在作用域中必须存在M[T]、K[T]类型的隐式值|
|T<%M<%K|在作用域中必须存在T到M、T到K的隐式转换|
|K>:T<:M|M是T的超类，K也是T的超类|


```scala211
/**
  * 多重界定
  */
object Example11_9 extends App {
    class A[T]
    class B[T]

    implicit val a = new A[String]
    implicit val b = new B[String]

    def test[T:A:B](x:T)=println(x)
    test("test")

    implicit def t2A[T](x:T)=new A[T]
    implicit def t2B[T](x:T)=new B[T]

    def test2[T <% A[T] <%B[T]](x:T)=println(x)
    test2("test2")
}
```

## 11.7 协变与逆变


```scala211
/**
  * 协变
  */
object Example11_10 extends App {
    class List[+T](val head:T, val tail:List[T])
    val list:List[Any] = new List[String]("covariance", null)
}
```


```scala211
/**
  * 协变：逆变位置
  */
object Example11_11 extends App {
    class List[+T](val head: T,val tail: List[T]) {
        def prepend[U>:T](newHead:U):List[U] = new List(newHead,this)
        override def toString()=""+head
    }
    val list:List[Any] = new List[String]("covariance",null)
}
```


```scala211
/**
  * 逆变
  */
object Example11_12 extends App {
    class Person[-A] {
        def test(x:A):Unit = {
            println(x)
        }
    }

    val pAny = new Person[Any]
    val pStr:Person[String] = pAny
    pStr.test("Contravariance test ---")
}
```

## 11.8 高级类型


```scala211
/**
  * 使用单例类型时的链式调用(方法执行顺序)
  */
object Example11_13 extends App {
    class Pet {
        private var name:String = null
        private var weight:Float = 0.0f

        def setName(name:String):this.type={
            this.name=name
            this
        }

        def setWeight(weight:Float):this.type={
            this.weight=weight
            this
        }
        override def toString=s"name=$name,weight=$weight"
    }

    class Dog extends Pet{
        private var age:Int=0
        def setAge(age:Int):this.type={
            this.age=age
            this
        }
        override def toString=super.toString + s",age=$age"
    }
    println(new Dog().setAge(2).setName("Nancy").setWeight(20.0f))
    println(new Dog().setName("Nancy").setWeight(20.0f).setAge(2))
}
```


```scala211
/**
  * 类型投影  #
  */
object Example11_14 extends App {
    class Outter{
        val x:Int=0
        def test(i:Outter#Inner)=i
        class Inner
    }

    val o1 = new Outter
    val o2 = new Outter

    val inner2 = new o2.Inner
    val inner1 = new o1.Inner

    o1.test(inner1)
    o2.test(inner2)
}
```

### 类型别名
- 引入重命名不能带具体泛型参数类型
```
import java.util.{HashMap=>JavaHashMap}
```
- 类型别名必须指定具体泛型参数类型
```
type JavaHashMap=java.util.HashMap[String,String]
```


```scala211
/**
  * 抽象类型：在父类中类型不明确，而在子类中才能确定的类型
  */
object Example11_15 extends App {
    abstract class Food
    class Rice extends Food{
        override def toString="rice"
    }
    class Meat extends Food{
        override def toString="meat"
    }

    class Animal{
        type FoodType
        def eat(f:FoodType)=f
    }
    class Human extends Animal{
        type FoodType=Food
        override def eat(f:FoodType)=f
    }
    class Tiger extends Animal{
        type FoodType=Meat
        override def eat(f:FoodType)=f
    }
    val human = new Human
    val tiger = new Tiger
    println("Human eats " + human.eat(new Rice))
    println("Human eats " + human.eat(new Meat))
    println("Tiger eats " + human.eat(new Meat))
}
```

### 复合类型：继承一个类并混入若干trait

### 函数类型：
- 高阶函数可以将函数对象作为函数的参数
- 存在Function[T1,T2,T3,...,T(N+1)]个函数类型，N最大值为22
